29/11/2019
Siamo arrivati al punto in cui inviamo il pacchetto di prova di config e status tra le due parti, capendo quando arriva effettivamente il pacchetto, e avendo creato un meccanismo di sincronizzazione tramite la variabile sync nel firmware

a Test del pacchetto di configurazione digitale:
->Accensione led
->Spegnimento led
->dimmer
->input

b Test in cui queste funzione combinate
------------------------------------------------------------------------------------------------------------------

4o Problema: testati invio e ricezione per host e firmware del pacchetto di prova si può implemenare il pacchetto per il
	funzionamento dei pin digitali, sia per la configurazione sia per lo stato.
	In questo caso dobbiamo capire dove inserire la funzione che ha il compito di "smistare" i pacchetti, ovvero se
	richiamarla nella on Receive del firmware, oppure se portla dopo la flushInputBuffer nel while infinito.
	(io direi di metterla nel while)
	Questo lo testiamo inizialmente con le stampe sull'host, rimandando il pacchetto inviato con qualche modifica
5o Problema: Utilizziamo un pacchetto di stato per lo studio dei pin digitali

[
	Per riconoscere un pacchetto di stato/config per i pin analogici/digitali non usiamo il numero ma usiamo il nome
	dell'ID (es. TEST_PACKET_ID)
	Per ogni tipo di pacchetto possiamo richiamare una funzione diversa.
	In ingresso a questa funzione possiamo mandare il pacchetto e l'indirizzo alla sua area di memoria.
	esempio:
	void functions_smarthouse(PacketHeader *pacchetto)
	{
		//dobbiamo capire che pacchetto sia tra i 4 (per ora possibili)
		switch (pacchetto->type)
		{
			case :
		}
		
	}
]
----------------------------------------------------------------------------------------------------------------------
6o Problema: implementiamo il pacchetto analogico e lo testiamo con le stampe

7o Problema: implementiamo il pacchetto di stato per i pin analogici
-----------------------------------------------------------------------------------------------------------------------

8o Problema: implementiamo la shell (in parte già fatta in smarthouse_v3)
