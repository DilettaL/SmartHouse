Abbiamo creato packet_header.h in cui però dovremmo forse cambiare i valori delle define commentate.


->GRISETTI:
Grisetti apprezza la nostra idea...è già qualcosa
dentro include firmware portabile, strutture dati che wrappano le funzioni = interfacce astratte
Domanda luca: da progetto dipende da tante cose da dove cominciare (selvaggio per imparare) dopo che uno conosce si tira fuori la struttura  (a botte de pezza diventa na cagata cit.)
Dentro arch implementazione delle funzioni.
Quando compilo si usa un target ma compilo dipendentemente dalla cartella.
COMMON:
						LATO ARDUINO
stesso codice, compilato da avr e pc, essendo la parte comune. QUi si ha il concetto di pacchetto
Packet_header: pragma push/pop il compilatore ottimizza per l'architettura, questo comando permette di farlo, evitando padding bytes. (Imbracchiali tutti insieme) in questo modo ho lo stesso layout binario sia per avr che per pc
(seq incrementato di 1 per ogni pacchetto, perché il checksum dice se il pacchetto è perso, mentre questo identifica il flow dei pacchetti)
Tipo-size-sequenza
Nel caso di orazio molti pacchetti, essendo il protocollo organizzato in pacchetti. Funziona mandando un pacchetto che contiene l'header il cui tipo dice il tipo di pacchetto e il payload, la size e il numero di sequenza.
Quando ascolto dalla seriale i pacchetti sono in binario 
Per capire inizio /fine del pacchetto trama di sintonia. La macchina a stati vista è il packet decoder (stato desincronizzato AA55=trama di inizio pacchetto, tutti i caratteri che arrivano non li conto se non questi. Se ottengo 55 allora vado in stato che legge la size. Letta la size (quanto è grosso payload) passo nuovo stato in cui devo leggere il nmero di caratteri imposto dal payload. Ci si rimette poi in attessa se il checksum è bono. Da checksum, una volta ricevuto, si può ritornare di nuovo allo stateo di lettura, Programma che fa questo packetDecoder (dentro packet_handler)
I nostri pacchetti altra natura. I suoi sono di vario tipo (controllo (robot fai questo), configurazione, stato (periodicamente dalla macchina=info non richiste)
esempio: array di periferiche
ogni pacchetto inizia ocn l'header e il resto è il payload del pacchetto. Per controllare parametri posso inviare la struct con i suoi parametri, poi controllo sui parametri. (AVR dipendentemente da successo o insuccesso mantiene i parametri della eeprom oppure li sovrascrive con quelli della ram.
orazio lavora su vari sottosistemi
SystemStatus è un pacchetto che boom boom boom dice info su buffer, errors, tutte le cose successe.

un pacchetto per ogni elemento (mai riscrevere il client, mai cambiare il codice i pacchetti sono uguali per il tipo periferica)
La ricezione di ogni pacchetto implica un'azione (entra uno che deve razzella il codice) il protocollo suo secondo lui è la più semplice
Quindi abbiamo visto i pacchetti. Pensiamo come arduino, che si mette in ascolto, quando arriva il checksum se lo prende e deve farci qualcosa, se il pacchetto è ben formato. 
Per capire cosa fare con il pacchetto si usa il type di packetHeader che definisce l'azione, lo selezioni in modo che sia l'indice di un puntatore a funzione dentro ad un vettore, così posso collegarlo a quello che mi serve.

packet_handler (la funzione dentro al sorgente): ha un array di puntatori a funzione che prendono in pasto un oggetto di
questo tipo e un carattere. Lui ha un array di puntatori a funzione. 
Quando ricevi un pacchetto chiami una funzione e installa le "ops" di tipo PacketOperations, che è una struct che dice cosa
devi fare quando ricevi un pacchetto. Ad esempio c'è il richiamo ad una funzione che inizializza il buffer. Si chiama una
funzione a cui si delega, risparmiando una copia. La Onreceive (packetFn) puntatore a inizio pacchetto quando lo si riceve.
Packet_handler_test fa proprio questo (test di unchain)
il packet_handler fa proprio questo, quando legge il pacchetto completo è lui stesso a chiamare la callBack di quel pacchetto
La funzione sendPacket permette di rimandarlo una volta ricevuto (ovviamente ricrementando il seq number). 
Definito: dove scriverlo e cosa fare.
PacketOperation ops(non è packetops) struct che contenere tutte le caratteristiche dei pacchetti
Se si vuole aggiungere un pacchetto basta installarlo
							LATO PC:
(Lo chiama Sabrina "Pronto Sabrì dimme tutto, è sempre un piacere sentitte, ciao cara". Dice che è un fenomeno e l'unica brava brava brava. Quando qualcosa lo fomenta ripete l'aggettivo x3, vedi riga 23)
Sta andando sulla cartella html, ma non si capisce bene. Intanto fa cose.
da circa minuto 35:
Dato che c'è una festa sulla seriale si potrebbero eliminare dei pacchetti? non ho capito molto quello che dice 

DEFERRED_PACKET_HANDLER
Visto che la cpu è una merda, ci sono delle operazioni pesanti che non vuoi eseguire subito, ma si possono eseguire dopo.
Allora c'è questa struttura che associa ad ogni pacchetto un buffer circolare di buffer di quel tipo. Nel momento in cui si vuole processare lui svuota il buffer e associa ad ogni pacchetto un buffer di quel tipo.
ProcessPendingPackets che una volta chiamata 
minuto 41:
Per capire quando è finita un'epoca ( l'istante dal quale ha inizio il conteggio del tempo di sistema in un particolare hardware) c'è un pacchetto speciale che si chiama endEpochPacket, che viene sempre mandato, anche se disabilitano tutti pacchetti. E' un header (pacchetto vuoto).
Quando pacchetto arriva, prendi indice, smucina se lo trovi ok altrimenti errore. 

Per la shell bisogna andare in host_test, orazio_packet_test 
(non c'è un esempio piccolo perché lui li sbraga sempre) ok ci dovrebbe essere...ma è in "cose" packet_orazio_respons_test dovrebbe essere che è il lato pc. E' praticamente simmetrico rispetto a quello di arduino
->mamma mia quant'è bona sabrina, sabrina ti amooooooooooooooooooooooooooooooooooooooooooooooooo
--------------------------------------------------------------------------------------------------------------------

Stiamo vedendo FlushInput/Output buffer che utilizzano le funzioni di packet_handler c

FlushOutput utilizza PacketHandler_txByte (dichiarata in packet_handler.c) e accetta come argomento un elemento della struct
PacketHandler sempre definita in questo file
Esempio: if(!a)-> entra nell'if solo se a=0

packet_handler è un elemento di tipo DeferredPacketHandler definito in deferred_packet_handler.h. E' una struct (di cui un elemento è "base_handler", elemento in ingresso alla funzione PacketHandler_txByte).
Il tipo DeferredPacketHandler gestisce il pacchetto corrente e i pacchetti in attesa. GESTISCE LA FILA! 

Stiamo guardando più il basso livello. I pacchetti vengono gestiti tramite packet_operation in cui packetStatus è il nostro automa della comunicazione.
Il pacchetto dovrebbe essere PacketHeader, "seq": numero progressivo per sapere se si sono persi dei pacchetti
(Grisetti: è una specie di checksum per sapere se si sono saltati dei pacchetti)

Pacchetto: Header+Payload+Checksum
orazio ha un header comune (contiene il tipo, in base ad esso ci attacca un payload, che è la stringa)

Il nostro pacchetto è formato da più struct
1) (da packetheader.h)
  typedef struct {
    PacketType type;  // type of the packet < PACKET_TYPE_MAX
    PacketSize size;  // size of the packet in bytes
    PacketSeq  seq;   // sequential number always increased
  } PacketHeader;
stiamo guardando orazio_packet
(#pragma pack(push, 1) dice al compilatore per mantenere la struttura della data struct, in questo modo arduino/pc sono collegati) 
----------------------------------------------------------------------------------------------------------------------------

Makefile definitivo: contiene tutti insieme i .c e i .h di tutti i file, senza distinzione per il basso/alto livello. Aggiungere i percorsi file
Makefile teensy: vengono utilizzati i .h di orazio_fimware e common, ma sembra che utilizzi i .o già fatti di arch (non penso sia un problema)

Directory altolivello:
ci sono due cartelle contenti due file orazio.c (in cui sono presenti i main)
---->>>orazio_firmware -> nel makefile teensy sono utilizzati i .h di questa cartella<<<<----- file dichiarano gli handler.h
-orazio_host (questa usa i threads)

Common:
packet_handler: file gestione del pacchetto, apposito test (quando lo devi mandare?)
deferred_packet_handler: file gestione del pacchetto rinviato, apposito test (quando lo devi ricevere?)

Queste funzioni vengono utilizzate nei test di orazio_firmware

Orazio_param.c utilizza la funzione della eeprom per scrivere/leggere da alto livello?

Come sono richiamate i sorgenti dall'alto al basso livello:
orazio.c richiama orazio_comm.c richiama deferred_packet_handler.h che richiama packet_handler.h

Orazio.c:
c'è il main. Come prima cosa vengono richiamate tutte le funzioni init
"// loop foreva"
c'è un loop infinito in cui sono richiamate le funzioni di orazio_comm

Orazio_comm:
Funzioni che permettono l'invio di un pacchetto

Definiti i vari tipi di pacchetto, che sono poi (FORSE) esplicitati in orazio_globals
Vengono utilizzate le 2 funzioni di deferred_packet_handler
-->Inoltre è in questo file che viene inclusa la uart.h e viene usata
deferred_packet_handler:
2 funzioni:
->_initialize (pacchetto inizializzare)
->_processPendingPackets (pacchetto in attesa di processo)

Quindi orazio->orazio_comm->uart.h


