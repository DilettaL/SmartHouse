Dobbiamo capire come può essere strutturato il nostro programma partendo dall'interfaccia con l'utente.
Da specifiche la nostra shell deve presentarsi così
            $> smart_house_host set_name kitchen_controller
            $> smart_house set_channel_name kitchen_controller switch_0 "top_fridge"
            $> smart_house set_channel_value "top_fridge" 1
            $> smart_house kitchen_controller query_channels
ovvero dobbiamo
1)Decidere il nome del dispositivo
2)decidere il nome del pin
3)definirne il valore o acquisirlo
In questo passo 3 dovremmo ricevere o un valore di corretta impostazione (uno stato) o un risultato di ritorno.

Provo quindi a definire l'insieme dei comandi che l'utente può inserire:
- "quit": chiude il dispositivo (return 0)
- "set_name": definisce il nome del dispositivo
- "set_channel_name": definisce il nome del pin da controllare
- "dimmer": dimmer di un led
- "ledOff": spegnimento led
- "ledOn": accensione led 
- "input": questo comando può eventualmente essere riferito o ai pin analogici(ADC) o ai pin digitali
Provo a creare due file "smarthouse_commands.c" e "smarthouse_commands.h" nella cartella "HighLevel_Pc"
------------------------------------------------------------------------------------------------------------------------------
Abbiamo capito che il nostro programma devo essere costituito da due codici binari.
Un elf è quello che definisce il funzionamento di arduino e uno che definisce il funzionamento da PC. Ognuno di essi deve essere correlato da un makefile. Il makefile riferito ad arduino deve contenere anche il codice per essere inviato alla board tramite seriale, mentre invece quello su pc necessita solo del gcc.

In questo file si tenta di capire quali file vanno utilizzati e come per creare il programma che deve funzionare da pc.
Si fa riferimento alla cartella "orazio_host".

1) "Orazio.c"
Si crea nella cartella pc il file smarthouse_pc.c, che contiene il main del programma da far funzionare su pc.
come detto dal prof serviranno due thread che da pc si mettono in ascolto dalla tastiera e dalla seriale. 
Sono due i file principali da cui vengono richiamate le funzioni in orazio.c: orazio_client.c e orazio_shell_globals.c
Come è stato già detto, il nostro file dovrà contenere due thread, uno per la tastiera e uno per la seriale. Invece in orazio.c, essendo la comunicazione con il robot via internet, si ha yb


2)"orazio_client.c"
In questo file sono richiamate le funzioni PacketHandler _txByte e PacketHandler _rxByte per la ricezione e invio dei pacchetti.

3)"orazio_shell_globals.c"
E' il file all'interno del quale si inizializza la shell e si crea l'interfaccia con l'utente, ovvero si richiamano le funzioni per interpretare i comandi inseriti da tastiera "executeCommand", etc etc
In generale tutte le sottofunzioni che permettono di interfacciare l'utente con il programma sono contenute in orazio_shell_commands.c

4)"orazio_shell_commands.c"
I comandi inseribili sono inseriti in una struct e, all'interno di ogni elemento di essa, sono contenute anche le rispettive funzioni.

