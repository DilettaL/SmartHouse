Ogni punto è inserito e indicato, sia nei file che ad inizio descrizione, nell'apposito file .c o .h
Alla fine o duurante la descrizione è nominato il file da cui è prelevato il codice

1)
Buffer_utils.h contiene delle macro utilizzate dalle funzioni della uart del basso e alto livello. Viene utilizzata da packet_handler.c nel nostro caso l'unico sorgente è packet_avr_common.c

2)
packet_avr_common.c: Parto considerando che in packet_avr_common.c dovrà essere presente il packet_handler, che non è altro che una macchina a stati per identificare lo stato di ricezione del pacchetto da parte di avr. Questo gestore prevede 6 funzioni che permettono di passare da uno stato all'altro.
(Ripreso da packet_handler.c)

3)
Queste funzioni prevedono due tipi non standard che sono PacketStatus e PacketHandler
3.a) packet_avr_common.h:
PacketStatus è il valore di ritorno delle possibili funzioni, e indica che tipo di risposta ha avuto il sistema, sia in caso di errore che di successo. E' fondamentalmente un intero, a cui è associato un nome. Per dichiarare questa struttura si utilizza l'enum.
(Ripreso da packet_operations.h)
3.b) packet_avr_common.h:
PacketHandler è una struct che contiene le info sulla trasmissione, la ricezione e puntatori a funzione
per ora la inserisco commentata e poi man mano aggiungo pezzi.
La definzione "struct PacketHandler;" non so se sia necessaria o meno, nel caso in fase di test si può verificare
(Ripreso da packet_handler.h)

Si vogliono ora capire cosa sono gli elementi della struct PacketHanlder. Da qui in poi in ogni indice è descritto un elemento di PacketHandler

4) Tutto scritto in packet_avr_common.h:
Nei punti di questo argomento si analizza il primo elemento della struct PacketHanlder ovvero "PacketOperations *operations[PACKET_TYPE_MAX];"
4a) "PACKET_TIPE_MAX" è dichiarato in packet_header.h e permette di definire un array di elemeni PacketOperations pari al numero di pacchetti che si vogliono usare
4b) "PacketOperations" è una struct dichiarata in packet_operations.h, commento inizialmente tutti i campi.
La definzione "struct PacketOperations;" non so se sia necessaria o meno, nel caso in fase di test si può verificare
(Ripreso da packet_operations.h)
4c) QUESTO PUNTO E' STATO ELIMINATO MA E' IMPORTANTE AI FINI DEL RAGIONAMENTO LOGICO LEGGERE LA SEGUENTE DESCRIZIONE:
Questa struct ha come primi due elementi, gli stessi della struct PacketHeader dichiarata in packet_header.h. Vado quindi a sostituirli direttamente con la struct.
4d)Vado a riprendere da packet_header.h,la struct con definizione dei tipi di dato contenuti al suo interno. Questa struct corrisponde all'header del pacchetto, che dovrà essere sempre inserita in ognuno di esso. A quanto pare il tipo di pacchetto e la sua dimensione servono anche alle operazioni sugli stati come infatti previsto dalla loro descrizione (pdf Luca)
4e) QUESTO PUNTO E' STATO ELIMINATO MA E' IMPORTANTE AI FINI DEL RAGIONAMENTO LOGICO LEGGERE LA SEGUENTE DESCRIZIONE:
Controllo quali elementi della struct PacketOperation sono utilizzati.
In packet_handler.c della struct, che è chiamata "ops", viene utilizzato solo type. mantengo quindi il packetHeader
In deferred_packet_handler viene usata nella definizione di DeferredPacketOps ma mai utilizzata (o almeno credo)
In orazio_firmware viene utilizzata una struct "HbridgeOps *ops" ma non è dello stesso tipo.
Quindi per ora resta quasi tutto commentato. 
4f) Scommento la 1a riga della struct PacketHandler ovvero "PacketOperations *operations[PACKET_TYPE_MAX];" in modo da poter identificare le caratteristiche e le eventuali operazioni di ogni pacchetto.

5)Tutto scritto in packet_avr_common.h:
5a) "PacketOperations* rx_current_op;"
Questo è un puntatore di tipo PacketOperations*. Probabilmente (anche dal nome) punta alla struct che identifica i parametri della corrente operazione, ed è utilizzato infatti in packet_handler.c
5b) Poiché in packet_handler vado ad accedere a PacketOPerations leggendo sia tipo che size elimino l'elemento PacketHeader, aggiunto nel punto 4c) e mantengo gli elementi della struct di partenza.
L'aver aggiunto PacketHeader con le sue definizioni ha comunque la sua utilità in quanto sono presenti le definizioni di tipo di size e type
5c) Si osserva che (sempre in packet_hanlder.c) gli elementi inizialmente non utilizzati di PacketOperations, e commentati nel punto 4e), sono utilizzati proprio da questo puntatore a funzione quindi si scommentano analizzandoli:
Questi elementi non sono altro che due funzioni con i relativi argomenti.
La loro funzione viene chiarita in seguito (sempre se ci arrivo)
5d)Le funzioni definite in PacketOperations devono però essere inizializzate, essendo dei tipi non standard. Il motivo per cui si definiscono nuovi tipi per queste funzioni, nonostante quelli utilizzati come argomenti e valore di ritorno sono già dichiarati, è perché si trovano dentro una struct; questo renderebbe impossibile il passaggio dei parametri e l'analisi del valore di ritorno. Con un nuovo tipo possiamo invece gestire tutto ciò.
(Ripreso da packet_operations.h)

6)Tutto scritto in packet_avr_common.h:
L'elemento "PacketHeader* rx_current_packet;" è un puntatore alle info del corrente pacchetto, PacketHeader appunto

7)Tutto scritto in packet_avr_common.h:
Gli elementi " uint8_t rx_checksum; uint8_t* rx_buffer; uint8_t* rx_buffer_end;" definisco le informazioni necessarie ad arduino per ricevere il pacchetto.

8)Tutto scritto in packet_avr_common.h:
8a)L'elemento "PacketHandlerRxFn rxFn;" della struct permette di richiamare una funzione. Essendo tale funzione un elemento della struct essa deve esse ridefinita con un tipo, in modo da poterle passare i parametri ed analizzare il valore di ritorno (come visto in precedenza).
8b)Questa funzione chiamata così in modo generico permette di richiamare le funzioni che compongono la macchina a stati, definite in 2).

9)Tutto scritto in packet_avr_common.h:
Sono elementi che permettono di regolare le informazioni quando arduino trasmette al pc (non so se sono necessarie poiché non dovrebbe essere richiesta la parte di codice relativa al deferred)
