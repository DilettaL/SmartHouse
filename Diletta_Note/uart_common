Stiamo vedendo FlushInput/Output buffer che utilizzano le funzioni di packet_handler c

FlushOutput utilizza PacketHandler_txByte (dichiarata in packet_handler.c) e accetta come argomento un elemento della struct
PacketHandler sempre definita in questo file
Esempio: if(!a)-> entra nell'if solo se a=0

packet_handler è un elemento di tipo DeferredPacketHandler definito in deferred_packet_handler.h. E' una struct (di cui un elemento è "base_handler", elemento in ingresso alla funzione PacketHandler_txByte).
Il tipo DeferredPacketHandler gestisce il pacchetto corrente e i pacchetti in attesa. GESTISCE LA FILA! 

Stiamo guardando più il basso livello. I pacchetti vengono gestiti tramite packet_operation in cui packetStatus è il nostro automa della comunicazione.
Il pacchetto dovrebbe essere PacketHeader, dobbiamo capire come si mette l'informazione in "seq" (e se va messa li)
----------------------------------------------------------------------------------------------------------------------------

Makefile definitivo: contiene tutti insieme i .c e i .h di tutti i file, senza distinzione per il basso/alto livello. Aggiungere i percorsi file
Makefile teensy: vengono utilizzati i .h di orazio_fimware e common, ma sembra che utilizzi i .o già fatti di arch (non penso sia un problema)

Directory altolivello:
ci sono due cartelle contenti due file orazio.c (in cui sono presenti i main)
---->>>orazio_firmware -> nel makefile teensy sono utilizzati i .h di questa cartella<<<<----- file dichiarano gli handler.h
-orazio_host (questa usa i threads)

Common:
packet_handler: file gestione del pacchetto, apposito test (quando lo devi mandare?)
deferred_packet_handler: file gestione del pacchetto rinviato, apposito test (quando lo devi ricevere?)

Queste funzioni vengono utilizzate nei test di orazio_firmware

Orazio_param.c utilizza la funzione della eeprom per scrivere/leggere da alto livello?

Come sono richiamate i sorgenti dall'alto al basso livello:
orazio.c richiama orazio_comm.c richiama deferred_packet_handler.h che richiama packet_handler.h

Orazio.c:
c'è il main. Come prima cosa vengono richiamate tutte le funzioni init
"// loop foreva"
c'è un loop infinito in cui sono richiamate le funzioni di orazio_comm

Orazio_comm:
Funzioni che permettono l'invio di un pacchetto

Definiti i vari tipi di pacchetto, che sono poi (FORSE) esplicitati in orazio_globals
Vengono utilizzate le 2 funzioni di deferred_packet_handler
-->Inoltre è in questo file che viene inclusa la uart.h e viene usata
deferred_packet_handler:
2 funzioni:
->_initialize (pacchetto inizializzare)
->_processPendingPackets (pacchetto in attesa di processo)

Quindi orazio->orazio_comm->uart.h


