Abbiamo creato packet_header.h in cui però dovremmo forse cambiare i valori delle define commentate.


->GRISETTI:
Grisetti apprezza la nostra idea...è già qualcosa
dentro include firmware portabile, strutture dati che wrappano le funzioni = interfacce astratte
Domanda luca: da progetto dipende da tante cose da dove cominciare (selvaggio per imparare) dopo che uno conosce si tira fuori la struttura  (a botte de pezza diventa na cagata cit.)
Dentro arch implementazione delle funzioni.
Quando compilo si usa un target ma compilo dipendentemente dalla cartella.
COMMON:
stesso codice, compilato da avr e pc, essendo la parte comune. QUi si ha il concetto di pacchetto
Packet_header: pragma push/pop il compilatore ottimizza per l'architettura, questo comando permette di farlo, evitando padding bytes. (Imbracchiali tutti insieme) in questo modo ho lo stesso layout binario sia per avr che per pc
(seq incrementato di 1 per ogni pacchetto, perché il checksum dice se il pacchetto è perso, mentre questo identifica il flow dei pacchetti)
Tipo-size-sequenza
Nel caso di orazio molti pacchetti, essendo il protocollo organizzato in pacchetti. Funziona mandando un pacchetto che contiene l'header il cui tipo dice il tipo di pacchetto e il payload, la size e il numero di sequenza.
Quando ascolto dalla seriale i pacchetti sono in binario 
Per capire inizio /fine del pacchetto trama di sintonia. La macchina a stati vista è il packet decoder (stato desincronizzato AA55=trama di inizio pacchetto, tutti i caratteri che arrivano non li conto se non questi. Se ottengo 55 allora vado in stato che legge la size. Letta la size (quanto è grosso payload) passo nuovo stato in cui devo leggere il nmero di caratteri imposto dal payload. Ci si rimette poi in attessa se il checksum è bono. Da checksum, una volta ricevuto, si può ritornare di nuovo allo stateo di lettura, Programma che fa questo packetDecoder (dentro packet_handler)
I nostri pacchetti altra natura. I suoi sono di vario tipo (controllo (robot fai questo), configurazione, stato (periodicamente dalla macchina=info non richiste)
esempio: array di periferiche
ogni pacchetto inizia ocn l'header e il resto è il payload del pacchetto. Per controllare parametri posso inviare la struct con i suoi parametri, poi controllo sui parametri. (AVR dipendentemente da successo o insuccesso mantiene i parametri della eeprom oppure li sovrascrive con quelli della ram.
orazio lavora su vari sottosistemi
SystemStatus è un pacchetto che boom boom boom dice info su buffer, errors, tutte le cose successe.

un pacchetto per ogni elemento (mai riscrevere il clien, mai cambiare il codice i pacchetti sono uguali per il tipo periferica)
La ricezione di ogni pacchetto implica un'azione
(entra uno che deve razzella il codice)
il protocollo suo secondo lui è la più semplice

Quindi abbiamo visto i pacchetti. Pensiamo come arduino, che si mette in ascolto, quando arriva il checksum se lo prende e deve farci qualcosa.
Per fare questo esiste il type che definisce l'azione, lo selezioni in modo che sia l'indice di un puntatore a funzione dentro un vettore

packet_handler: array di puntatori a fuznione che prendono in pasto un oggetto di questo tipo e un carattere

->
--------------------------------------------------------------------------------------------------------------------

Stiamo vedendo FlushInput/Output buffer che utilizzano le funzioni di packet_handler c

FlushOutput utilizza PacketHandler_txByte (dichiarata in packet_handler.c) e accetta come argomento un elemento della struct
PacketHandler sempre definita in questo file
Esempio: if(!a)-> entra nell'if solo se a=0

packet_handler è un elemento di tipo DeferredPacketHandler definito in deferred_packet_handler.h. E' una struct (di cui un elemento è "base_handler", elemento in ingresso alla funzione PacketHandler_txByte).
Il tipo DeferredPacketHandler gestisce il pacchetto corrente e i pacchetti in attesa. GESTISCE LA FILA! 

Stiamo guardando più il basso livello. I pacchetti vengono gestiti tramite packet_operation in cui packetStatus è il nostro automa della comunicazione.
Il pacchetto dovrebbe essere PacketHeader, "seq": numero progressivo per sapere se si sono persi dei pacchetti
(Grisetti: è una specie di checksum per sapere se si sono saltati dei pacchetti)

Pacchetto: Header+Payload+Checksum
orazio ha un header comune (contiene il tipo, in base ad esso ci attacca un payload, che è la stringa)

Il nostro pacchetto è formato da più struct
1) (da packetheader.h)
  typedef struct {
    PacketType type;  // type of the packet < PACKET_TYPE_MAX
    PacketSize size;  // size of the packet in bytes
    PacketSeq  seq;   // sequential number always increased
  } PacketHeader;
stiamo guardando orazio_packet
(#pragma pack(push, 1) dice al compilatore per mantenere la struttura della data struct, in questo modo arduino/pc sono collegati) 
----------------------------------------------------------------------------------------------------------------------------

Makefile definitivo: contiene tutti insieme i .c e i .h di tutti i file, senza distinzione per il basso/alto livello. Aggiungere i percorsi file
Makefile teensy: vengono utilizzati i .h di orazio_fimware e common, ma sembra che utilizzi i .o già fatti di arch (non penso sia un problema)

Directory altolivello:
ci sono due cartelle contenti due file orazio.c (in cui sono presenti i main)
---->>>orazio_firmware -> nel makefile teensy sono utilizzati i .h di questa cartella<<<<----- file dichiarano gli handler.h
-orazio_host (questa usa i threads)

Common:
packet_handler: file gestione del pacchetto, apposito test (quando lo devi mandare?)
deferred_packet_handler: file gestione del pacchetto rinviato, apposito test (quando lo devi ricevere?)

Queste funzioni vengono utilizzate nei test di orazio_firmware

Orazio_param.c utilizza la funzione della eeprom per scrivere/leggere da alto livello?

Come sono richiamate i sorgenti dall'alto al basso livello:
orazio.c richiama orazio_comm.c richiama deferred_packet_handler.h che richiama packet_handler.h

Orazio.c:
c'è il main. Come prima cosa vengono richiamate tutte le funzioni init
"// loop foreva"
c'è un loop infinito in cui sono richiamate le funzioni di orazio_comm

Orazio_comm:
Funzioni che permettono l'invio di un pacchetto

Definiti i vari tipi di pacchetto, che sono poi (FORSE) esplicitati in orazio_globals
Vengono utilizzate le 2 funzioni di deferred_packet_handler
-->Inoltre è in questo file che viene inclusa la uart.h e viene usata
deferred_packet_handler:
2 funzioni:
->_initialize (pacchetto inizializzare)
->_processPendingPackets (pacchetto in attesa di processo)

Quindi orazio->orazio_comm->uart.h


